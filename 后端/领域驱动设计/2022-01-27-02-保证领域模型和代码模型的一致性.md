---
slug: 保证领域模型和代码模型的一致性
title: 保证领域模型和代码模型的一致性
author: Jessie
author_title: 后端开发
author_url: https://github.com/OnfireMrHuang
author_image_url: https://avatars.githubusercontent.com/u/22336719?v=4
tags: [Golang, Rust, kubernetes, spark, Java]
---


DDD 强调先构建领域模型然后设计微服务，以保证领域模型和微服务的一体性，因此我们不能脱离领域模型来谈微服务的设计和落地。但在构建领域模型时，我们往往是站在业务视角的，并且有些领域对象还带着业务语言。我们还需要将领域模型作为微服务设计的输入，对领域对象进行设计和转换，让领域对象与代码对象建立映射关系。

**前篇中我们构建了领域模型、代码模型，这章我们讨论如何将它们结合起来**

按照一般的思路，我们只需要将限界上下文对应成一个个的微服务，并把内部的聚合、实体、值对象映射到代码模型中就好了，但是这样做之前，我们还是有必要再做进一步的设计和分析:

* 分析微服务内有哪些服务？
* 服务所在的分层？
* 应用服务由哪些服务组合和编排完成？
* 领域服务包括哪些实体的业务逻辑?
* 采用充血模型的实体有哪些属性和方法？

## 设计实体

大多数情况下，领域模型的业务实体与微服务的数据库实体是一一对应的，但是再某些领域可能会设计为多个数据实体，或者实体的某些属性被设计为值对象。

比如分析个人客户时，还需要有地址、电话和银行账号等实体，它们被聚合根引用，不容易在领域建模时发现，我们需要在微服务设计过程中识别和设计出来。

在分层架构里，实体采用充血模型，在实体类内实现实体的全部业务逻辑。这些不同的实体都有自己的方法和业务行为，比如地址实体有新增和修改地址的方法，银行账号实体有新增和修改银行账号的方法。

实体类放在领域层的 Entity 目录结构下。

## 找出聚合根

聚合根是一种特殊的实体，它有自己的属性和方法。聚合根可以实现聚合之间的对象引用，还可以引用聚合内的所有实体。聚合根类放在代码模型的 Entity 目录结构下。聚合根有自己的实现方法，比如生成客户编码，新增和修改客户信息等方法。

聚合根类放在代码模型的 Entity 目录结构下。

## 设计值对象

如果这个领域对象在其它聚合内维护生命周期，且在它依附的实体对象中只允许整体替换，我们就可以将它设计为值对象。如果这个对象是多条且需要基于它做查询统计，我建议将它设计为实体。

值对象类放在代码模型的 Entity 目录结构下。

## 设计领域事件

如果领域模型中领域事件会触发下一步的业务操作，我们就需要设计领域事件。首先确定领域事件发生在微服务内还是微服务之间。然后设计事件实体对象，事件的发布和订阅机制，以及事件的处理机制。判断是否需要引入事件总线或消息中间件。

领域事件实体和处理类放在领域层的 Event 目录结构下。领域事件的发布和订阅类我建议放在应用层的 Event 目录结构下。

## 设计领域服务

如果一个业务动作或行为跨多个实体，我们就需要设计领域服务。领域服务通过对多个实体和实体方法进行组合，完成核心业务逻辑。你可以认为领域服务是位于实体方法之上和应用服务之下的一层业务逻辑。

按照严格分层架构层的依赖关系，如果实体的方法需要暴露给应用层，它需要封装成领域服务后才可以被应用服务调用。所以如果有的实体方法需要被前端应用调用，我们会将它封装成领域服务，然后再封装为应用服务。

领域服务类放在领域层的 Service 目录结构下。

## 设计仓储

每一个聚合都有一个仓储，仓储主要用来完成数据查询和持久化操作。仓储包括仓储的接口和仓储实现，通过依赖倒置实现应用业务逻辑与数据库资源逻辑的解耦。

仓储代码放在领域层的 Repository 目录结构下。

## 应用层的领域对象

应用层的主要领域对象是应用服务和事件的发布以及订阅。

* 在应用层和领域层分别会发生哪些业务行为；
* 各层分别需要设计哪些服务或者方法；
* 这些方法和服务的分层以及领域类型（比如实体方法、领域服务和应用服务等），它们之间的调用和组合的依赖关系。

在严格分层架构模式下，不允许服务的跨层调用，每个服务只能调用它的下一层服务。服务从下到上依次为：实体方法、领域服务和应用服务。
