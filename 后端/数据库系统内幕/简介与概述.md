# 简介与概述

分布式算法的多种不同用途

- 协调 — 监督若干工作者的动作和行为的进程
- 合作 — 多个参与者互相依靠，共同完成任务
- 分发 — 进程相互配合，将信息快速而可靠地分发给感兴趣的进程
- 共识 — 在多个进程间达成共识

## 一、并发执行

![Untitled](%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%A6%82%E8%BF%B0%206e44186da918496b96d17cf5798e9684/Untitled.png)

为了减少并发场景下可能出现的结果数量，我们需要一致性模型(将无序规范为有序)；一致性模型描述了并发执行的过程，并且确定了运算执行以及对其他参与者可见的顺序，使用不同的一致性模型，我们可以约束或放松系统可能的状态数量。

### **分布式系统中的共享状态**

并发系统中存在共享内存，进程利用它交换信息。在分布式系统中，各个进程拥有自己的本地状态，当然也可以在其中引入共享内存的概念，比如数据库。

为了访问数据库，就需要通过通信介质来发送和接受信息，来查询或修改状态。但是访问可能会不可避免的遇到比如过载、不可用、响应太慢、网络异常等故障导致无法继续执行后面的算法步骤。如果系统在故障发生时仍然能继续正常运行，那该特性就被我们称为容错性。故障可能存在很多类型，比如临时性故障、消息丢失、乱序等等，所以需要一个故障模型来描述故障可能发生的方式，然后决定如何处理它们。

## 二、分布式计算的误区

### 1、通信链路上的异常

通过链路传递消息时可能出错的地方:

- 网络的可靠性
- 延迟和带宽假设
- 网络的安全性
- 可能存在的攻击者、有意或无意的拓扑变化
- …

### 2、本地处理的延迟

消息到达远程进程后并不一定是立即处理，或者处理也会因为CPU、内存、磁盘配置以及不同的软件版本和配置出现不一样的处理速度；同时远端可能也是通过一个队列来消费请求，如果消费端的处理速度小于生产端的生产速度，那么请求的延迟将变得更大或者直接被丢弃。

### 3、时钟和时间

在不同的远程计算机上进行时钟同步是很危险的，因为不同远程计算机的本地时钟很可能存在误差，对于一些对时序和实时性要求比较高的数据处理中，往往通过时间的误差范围来保证正确性。

### 4、状态一致性

分布式算法并不总是保证状态的严格一致。往往分布式集群中允许各个副本之间的状态存在分歧，并最终一致。甚至是通过依赖冲突解决和读取时数据修复来实现。

### 5、本地和远程执行

将本地执行和远程执行共同隐藏在同一个API内部是危险的，因为两者的差异是很大的： 本地执行即使你对存储引擎不熟悉，也可以合理推测其内部行为。而远程执行你则需要理解一致性、传递语义、数据协调、分页、合并、并发访问等等，最明显的差异就是延迟、同时还涉及网络传输、序列化和反序列化等许多步骤

### 6、处理故障的需要

刚开始构建系统时，我们可以假设所有节点都可以正常工作。但是在长时间运行的系统中，节点可能会关机维护、因为软件问题崩溃等等。所以出现了一些分布式算法使用心跳协议和故障检测机制来确定哪些参与者还活着且可达。

### 7、网络分区和部分故障

当两个或更多服务器无法相互通信时，我们称这种情况为网络分区。网络的不可靠性令人烦恼但尚且可以容忍，而网络分区则更麻烦，因为各个独立的分组可以继续执行并产生冲突的结果。网络链路的故障也可能是不对称的：消息可以从一个进程传递到另一个进程，反之则不行。

所以在设计分布式系时，我们必须认真考虑容错性、弹性以及可能的故障场景和边缘情形。设计足够多的测试场景，比如用Toxiproxy模拟网络问题：限制带宽、引入延迟、超时等，用charybdeFS模拟文件系统及硬件错误和故障等来确保出现这些故障时软件仍能正确工作。CrashMonkey是一个与文件系统无关的记录-重放-测试框架，用于测试持久性文件的数据及元数据一致性。

### 8、级联故障

我们做不到完全的隔离故障，被高负载压垮的进程会增加集群其他部分的负载，从而使其他节点更有可能发生故障。级联故障能够从系统的一部分传播到另一部分，扩大问题的范围。

为了防止系统故障扩散并妥善处理故障场景，我们可以使用熔断机制。当客户端与某一台服务器的连接失败或服务器没有响应时，客户端将开始循环重连，这是过载的服务器已经难以应付新的连接请求，因而客户端的循环重试无济于事，为了避免这一情况，我们可以使用backoff策略，即不要立即重试，而是等待一段时间来避免问题扩大。但是使用相同backoff策略的多个客户端也会产生大量负载，为了防止多个客户端在backoff后同时重试，我们可以引入抖动(jitter)。 抖动在backoff上增加了一个小的随机时间间隔，从而降低多个客户端同时醒来并重试的可能性。

硬件故障、比特位腐烂和软件错误都会导致数据损坏，而损坏的数据会通过标准的传递机制传播，如果没有合适的验证机制，系统可能会将损坏的数据传播到其他节点，甚至会覆盖未损坏的数据记录。为了避免这种情况，我们通常采用校验和(checksum)的验证机制来验证节点之间交换的任何内容的完整性。

## 三、分布式系统抽象

讨论编程语言时，我们使用通用术语函数、运算符、类、变量和指针等来定义我们的程序。定义的概念越精确、越没有歧异，听众就越容易理解。

### 1、链路

**公平损失(fair-loss)链路:**

- 公平损失
    - 如果发送方和接受方都是正确的，且发送方无限多次重复发送，则消息最终会被送达
- 有限重复
    - 发送的消息不会被送达无限次
- 不会无中生有
    - 链路不会自己生成消息。它不会传递一个从未发送过的消息

消息确认

由于消息传递的不可靠，我们可以引入确认(acknowledgment)应答机制: 接收方通知发送方消息已送达，并增加一些措施来区分不同的消息，比如序列号—单调递增的唯一消息标识符。

消息重传

消息确认机制仍然不足以保证通信协议完全可靠: 发送的消息仍然可能丢失，远程进程也可能在确认之前发生故障,为了解决这个问题，则需要重传。

**重传的问题**

当我们发送消息时，在收到远程进程的确认之前，我们无从得知消息的状态: 可能已被处理、可能马上就要处理、也可能已经丢失，甚至可能在收到消息之前远程进程就崩溃了。我们可以重试操作在此发出消息，但这可能导致消息重复，只有我们要执行的操作是幂等时，处理重复消息才是安全的。

幂等(idempotent)的操作可以执行多次而产生相同的结果，且不会产生其他副作用。在存在部分故障和网络分区的情况下，幂等性尤其重要，因为我们无法确定远程操作的确切状态是成功还是失败，还是会被马上执行—我们只等等待更长的时间。保证每个操作都是幂等是不切实际的，因此我们需要在不改变实际操作语义的情况下，提供与幂等性等价的保证。为此，我们可以使用去重来避免多次处理消息。

**消息顺序**

不可靠的网络给我们带来了两个问题:  一个是消息可能会乱序到达；二是由于重传某些消息可能会多次送达。通过引入序列号，利用这些消息标识符我们可以在接收方确保先进先出的顺序。由于每条消息都有一个序列号，因此接收方可以跟踪如下信息:

- n-consecutive 最大连续序列号： 所有小于或等于该序列号的消息都已经收到。这些消息可以按顺序放到正确的位置上，同时接收方可以安全地丢弃收到的序列号小于n-consecutive的消息。
- n-processed表示最大已处理序列号: 所有小于或等于该序列号的消息都已经按照原来的顺序被处理。此序列号可以用于去重。

**严格一次传递(exactly-once delivery)**

> 分布式系统中只有两个难题: 1) 保证消息顺序；  2) 严格一次传递 — Mathias Verraes
> 

由于链路故障可能导致传递消息的第一次尝试无法成功，因此大多数实际的系统都采用至少一次传递(at-least-once delivery)，它确保了发送方将重试直到收到确认为止，否则就认为对方没有收到消息。还有一种传递语义是最多一次(at-most-once): 发送方仅仅发送消息而不期待得到任何确认。

为了确保严格一次传递，各节点需要一个共同知识：每个节点都知道某件事，每个节点都知道其他所有节点也都知道这件事。

## 四、两将军问题

一个被广泛称为两将军问题的思想实验，是对分布式系统一致性的最著名的描述之一。

这个思想实验声明，如果链路可能发生故障并且通信是异步的，则不可能在通信的双方之间达成共识。

## 五、FLP不可能定理

Fisher、Lynch和Paterson在论文中描述了一个著名的问题：FLP不可能问题，论文讨论了一种共识形式: 各进程启动时有一个初始值，并尝试就新值达成共识。算法完成后，所有正常进程上的新值必须相同。

如果网络完全可靠，很容易对特定值达成共识。但实际上，系统容易出现各式各样的故障，例如消息丢失、重复、网络分区，以及进程缓慢或崩溃。

论文指出如果我们不给进程完成算法步骤设定一个时间上限，那么就无法可靠地检测出进程故障，也不存在确定性的共识算法。

## 六、系统同步性

在异步模型中不一定能解决共识问题。而且，不一定能设计出高效的异步算法。对于某些任务，切实可性的解决方案很可能需要依赖时间。我们可以放宽一些假设，认为系统是同步的。为此我们引入了时间的概念，在同步模型下对系统进行推理要容易得多。它假定各进程的处理速度相近、传输延迟是有限的，并且消息传递不会花任意长的时间。

## 七、故障模型

故障模型可以准确地描述分布式系统中的进程可能以怎样的方式崩溃，并基于这些假设来开发算法.

### 1、崩溃故障

我们预期进程会正确执行算法的所有步骤。当进程停止执行接下来的算法步骤，并且不再发送任何消息给其他进程，那就说明进程崩溃了。

大多数情况下，我们可以使用崩溃-停止(crash-stop)进程抽象的进程，它规定一旦进程崩溃就会保持这种状态。

崩溃-恢复(crash-recovery)是另一种的进程抽象，在这种抽象中，进程停止执行算法步骤，但会在稍后恢复并尝试执行剩下的步骤。

### 2、遗漏故障

该模型假设故障进程跳过了某些算法步骤，或者无法执行这些步骤，或者执行过程中对其他参与者不可见，或者无法与其他参与者通信。

### 3、任意故障

进程继续执行算法步骤，但是以与违背算法的方式。此类故障可能是由于软件bug或运行不同版本算法的进程，在这种情况下，故障很容易被发现和理解。如果我们无法控制所有进程，并且其中一个进程有意地误导其他进程，则发现和理解故障会变得非常困难。

### 4、故障处理

我们可以通过构成进程组、在算法中引入冗余来掩盖故障: 即使其中一个进程发生故障，用户也不会注意到。

故障可能会带来一些性能损失: 正常执行依赖于进程可响应，而且系统必须回退到较慢的执行路径来处理故障和纠正错误。故障往往可以通过一些方式来避免，例如: 代码审查、广泛的测试、引入超时重试机制确保消息送达，以及确保各算法步骤在本地按顺序执行。

## 小结