# B树

## 一、二分搜索树

二分搜索树(BST)由多个节点组成，每个节点由一个键、一个与该键关联的值以及两个子节点指针组成，每个节点的搜索空间分为左子树和右子树，当前节点的键大于其左子树中存储的任何键，小于其右子树中存储的任何键。

### 1.1 树的平衡

插人操作并不会遵循任何特定模式，元素插入可能导 树不平衡的情况（即它的一个分支比另 个分支长）。最差的情况会退化为一个链表，此时得到的不是期望的对数时间复杂度而是线性时间复杂度。

树的平衡就是尽量保持树的高度为log2N,并且左右子树的高度差不大于1，以此来确保二叉搜索树的查询性能优势。

### 1.2 基于磁盘存储的树

二分搜索树的平均时间复杂度是O(log2n)，如果扇出较低(比如每个节点允许拥有的最大子节点数为1)，那么在插入和删除时可能会频繁地执行平衡操作、重新定位节点并更新指针。

如果想在磁盘上维护二分搜索树，面临的问题如下:

1. 局部性:  由于数据时随机添加的，所以不能保证新创建的节点是在父节点附近写入的，意味着节点子指针可能跨越多个磁盘页。
2. 另一个是树高问题: 由于二分树的扇出是2，所以树高是元素个数以2为底的对数。所以需要执行O(log2n)次查找来定位要搜索的元素，这就要求执行相同数量的磁盘传输。

考虑上述因素，更适合磁盘实现的树必须具有以下属性:

- 高扇出，改善相邻键值的数据局部性
- 低高度, 减少遍历期间的寻道次数

## 二、基于磁盘的结构

当数据量大到在内存中保存整个数据集是不可能或不可行时，通常就需要使用磁盘上的数据结构了。通常情况下我们都是一部分数据缓存在内存里，其他数据都以某种高效访问的方式存储在磁盘。

### 2.1 机械硬盘

机械磁盘(HDD)是旋转型磁盘，读取数据是通过旋转磁盘和机械磁头来定位到期望的位置，其最小的传送单位是扇区，因此执行操作时，至少要读取或写入一整个扇区。扇区大小通常是512B到4KB不等。

顺序IO可以带来正面效果的原因之一就是基于机械磁盘是通过磁头顺序旋转定位的特性。

### 2.2 固态硬盘

固态硬盘(SSD)没有需要旋转的磁盘，其通过记忆单元构成，然后往上组合记忆单元 —> 串 —> 阵列 —>页 —> 块

![Untitled](./B%E6%A0%91%E5%8E%9F%E7%90%86/Untitled.png)

读写的最小单位是页，通常大小是在2k-16k之间。但是写我们只能对空的记忆单元进行更改(即已经擦除的单元)，最小的擦除单元不是页，而是块，这也是为什么通常被称为擦除块。另外，空块中的页也必须是按照顺序来写入。

另外SSD的闪存控制器有一个组件叫闪存转换层，负责将页ID映射到对应的物理位置，并跟踪空的、被写过的、被丢弃的页。并且还负责垃圾回收，在此期间会查找可以被安全擦除的块，如果有些块可能仍然有活页，它可能会从这些块把活页迁移到新位置，然后重新映射页ID到新的物理位置。

**通过对HDD和SSD的了解，知道其都是面向一定量的数据而不是单字节来操作的，所以大多数操作系统都抽象了块设备这个概念，它隐藏内部的磁盘结构并在操作系统内部缓冲I/O操作，因此当我们读单个字节的时候，包含它的整个块会被读取，这是一个不能忽视的限制，在处理基千磁盘存储的数据结构时应该始终考虑到这一点。**

### 2.3 磁盘存储结构

**设计存储结构前的考量**

1. 磁盘操作的最小单元是块这个事实是构建有效的磁盘存储结构的主要限制和设计条件。要跟踪指向块内特定位置的指针，我们必须获取 整个块。既然不得不这样做，那么我们可以通过更改数据结构的布局来利用这个条件。
2. 在磁盘上，大部分时间我们都手动管理数据布局（除非我们使用内存映射文件）。虽
然这类似千常规指针的操作，但我们必须计算目标指针的地址井显式地追踪该指针
3. 在大多数情况下 磁盘上的偏移量是预先计算出来的（即指针在它所指向的那部分内
容被存储之前被写人磁盘），或者缓存在内存中直到其被刷写到磁盘上。在磁盘结构中
创建长依赖链会极大地增加代码和结构的复杂性，因此最好将指针的数桩及其跨度保
持最小。

总之，磁盘存储结构的设计要考虑到其目标存储介质的特性，并 通常要为实现更少的磁盘访问进行优化。我们可以通过提高局部性、优化结构的内部表示以及减少页外指针的数量来实现这点。所以我们得出结论，即高扇出和低高度是实现最佳磁盘数据结构所需的特性。我们还讨论了来自指针的额外空间开销，以及由于平衡而重新映射这些指针所带来的护开销。而B树结合了这些思想：增加节点扇出、减少树高和节点指针的数量、降低平衡操作的频率。

> 分页二叉树:
> 
> 
> 通过将节点分组到页来设计二分树的布局,改善了数据局部性。要找到下一个节点，只需在已经获取的页面中追踪指针即可。但是，其间的节点和指针仍然会产生一些开销。在磁盘上布局结构并进行进一步维护是项不容易的工作，特别是在键和值不是预先排好序而是以随机形式添加的时候。 平衡需要页重组，这又会导致指针更新。
> 

## 三、B树

正如上一节磁盘存储结构讨论到那样，B树是建立在平衡搜索树的基础上的，不同之处是B树具有更高的扇出和更低的高度。

### 3.1 B树的层次结构

B树由多个节点组成。每个节点最多可容纳 个键和 N+l 个指向子节点的指针。这些节点在逻辑上分为三类。

根节点 — 根节点没有父节点，是树的顶端
叶节点 — 叶节点是没有子节点的底层节点。
内部节点 — 连接根节点和叶节点的其他节点， 树通常包含多层的内部节点。

![Untitled](./B%E6%A0%91%E5%8E%9F%E7%90%86/Untitled%201.png)

B树的特征在于其扇出 (fanout ：存储 在每个节点中的键的个数。为保持树的平衡需要
做出 些结构上的更改，而更高的扇出则有助于均摊这些更改的所带来的开销。同时，
通过在单个块或多个连续块中存储指向 子节 点的键和指针，可以减少寻道的次数。平衡
橾作（即分裂和合并）会在节点已满或几乎为空时被触发。

### 3.2 分隔键

存储在 树节点中的键称为索引条目 (index entry) 、分隔键 (separator key) 或分隔符单
元格 (divider cell) 。它将树分割成子树（也称为分支或子范围），其持有包含对应键的范
围。键存储时已经排好序，以便使用二分搜索。查找算法通过定位 个键并跟随相应的
指针从较高的层次移动到较低的层次来找到一个千树。

![Untitled](./B树原理/Untitled%202.png)

使B树与众不同的是，它不是自上而下构建的（像二分搜索树那样），而是采用相反的构
建方式一自下而上。随着叶子节点数的增加，内部节点的数量和树的高度也将培加。

### 3.3 B树查找复杂度

可以从两个角度来讨论B树查找的复杂度：块传输的数量和查找期间完成的比较的次数。就传输次数而言，对数基 （每个节点的键数）。从根节点每往下走 节点个数就多K倍，并且跟随一个子指针可以将搜索空间减少至N分之一 。在查找期间，最多寻址logkM（其中M是B树中的项的总数）个页来查找 个搜索键。在从根到叶的通路上必须经过的子指针的数量也等于层数，换句话说，其等于树的高度。

从比较次数的角度来看，对数基是2 ，因为在每个节点内搜索一个键是使用二分搜索完成的。每次比较都将搜索空间减半，因此复杂度为 log2M

### 3.4 B树查找算法

从根节点上开始执行二分搜索算法，将要搜索的键与存储在根节点中的键进行比较，直到找到大于要搜索的键的第一个分隔键。这样便定位了一个要搜索的子树。正如前面所讨论的，索引键将树分割成多个子树，子树的边界位于两个相邻的键之间。 一旦找到子树，我们就顺着相应的指针继续相同搜索过程（定位分隔键然后顺着指针往下找），直到我们到达目标叶节点、在那里我们要么找到了搜索的键，要么通过定位它的前驱节点而得出它不存在的结论。

在进行单点查询时，在找到或找不到所搜索的键之后搜索便结束了。而在进行范围扫描时，迭代从找到的最近的键值对开始，并顺着同级指针继续移动，直到到达范围的末尾或用尽范围谓词为止。

### 3.5 键的数目

略

### 3.6 B树节点分裂

要将一个值插入 树，我们首先必须定位目标叶节点井找到插入点 为此，我们使用前面小节中描述的算法先进行查找操作。在定位叶节点之后，键和值被追加到叶节点之上。在B树中，更新操作则通过使用查找算法定位目标叶节点并将新值与现有键相关联来完成。
如果目标节点没有足够的可用空间，我们就说该节点溢出 (overflow) f [NICHOLS66],此时必须将其分裂为两部分才能放入新的数据。更准确地说，如果以下条件成立，则需要分裂节点:

- 对于叶节点： 如果节点最多可以容纳N个键值对，且再插入一个键值对将使其超过最大容量N.
- 对于非叶节点: 如果节点最多可以容纳N+1个指针，且再插入一个指针将使其超过最大容量N+1

分裂是通过分配新节点、将一半元素从原分裂节点传输给它井添加它的第一个键和指向父节点的指针来完成的。在这种情况下，我们说这个键被提升 (promote) 。执行分裂处的数组下标称为分裂点（也称为中点）。分裂点之后的所有元素（在非叶节点分裂的情况下，包括分裂点）都被传愉到新创建的兄弟节点，其余元素保留在分裂节点中。

如果父节点已满，即没有容纳被提升的键和指向新创建节点的指针的空间时，也必须分裂父节点。该操作可能会一直递归传播到根节点。

一旦树达到其容量，比如一直传播到根节点，我们就必须分裂根节点，当根节点被分裂时，将产生一个新的根，该根具有分裂点的键。旧根节点和新创建的同级节点一起被降级到下一层，从而使树高增加1。在分裂根节点或合并两个节点以形成新根时，树高会发生变化。在叶节点和内部节点所在的层上，树只水平生长。

![Untitled](./B树原理/Untitled%203.png)

![Untitled](./B树原理/Untitled%204.png)

### 3.7 B树节点合并

为了进行删除，首先要定位目标叶节点。当叶节点袚定位后，键和与其相关的值就被删除。如果相邻节点所拥有的值太少（即，其占用率低于阅值），则需要 合并同 层的节点、。这种情况称为下溢 (underflow) 。［BAYER72] 描述了两种下溢场 泉：如果两个相邻节点具有公共父节点 井且它们的内容能够放入单个节点，则它们的内容应该合并（连接起来）；如果它们的内 容无法放入单个节点，则应在它们之间重新分配键以恢复平衡。更准确地说 ，如果满足以下条件，则合并两个节点：

- 对于叶节点：如果一个节点可以容纳最多N个键值对，井且两个相邻节点中的键值对的数目加起来小与或等于N.
- 对于非叶节点：如果一个节点可以容纳最多 N+1 个指针，并且两个相邻节点中指针的数量加起来小于或等于 N+1。

![Untitled](./B树原理/Untitled%205.png)

![Untitled](./B树原理/Untitled%206.png)

在合井非叶节点时我们必须从父节点中下拉相应的分隔键（即降级）。父节点的指针数量减少 1 ， 因为合并是从下层传播指针删除的结果 ，指针的删除则是由删除页引起的。就像分裂一样，合并可以一直传播到根节点这 一层。

## 四、总结

首先介绍了需要创建磁盘存储专用结构的动机，然后指出二分搜索树可能具有相似的复杂度特性，但因为扇出低，且平衡会引起大量数据移动和指针更新，所以不是特别适用于磁盘。而B树则通过增加每个节点中存储的数据项来增加扇出，同时减少平衡操作的频率来解决这两个问题。

随后，讨论了B树的内部结构和原理，其插入、查找和删除操作的算法概要。分裂和合并操作有助于重新构造树，以便在添加和删除元素时保持树的平衡。