# B树实现

该篇各节在逻辑上分为三组:

- 讨论数据组织:  如何建立键和指针之间的关系，以及如何实现页头和页之间的链接
- 讨论从根节点到叶子结点的整个下降过程: 包括如何执行二分搜索，如何收集相关内容并跟踪父节点，以备后续发生节点的分裂或合并时使用。
- 讨论优化技术(再平衡、仅在右边追加和批量加载)、维护过程和垃圾收集。

## 页头

页头保存有关可用于页定位、维护和优化的信息。通常包含描述页内容和布局的标志位、单元格数量、标记空闲空间的上界与下界偏移量以及其他有用的元数据。

### 1、魔数

页头通常放置的一个值是魔数，比如: 50 41 47 45, 该数值通常用来标识页的类型、版本以及用作校验和完整性检查。

### **2、同级指针**

定位一个同级节点，如果没有同级指针，那么我们需要通过父节点才能定位到。该操作可能会一直上升到根节点，因为直接父节点只能帮我们找到它自己的子一级节点，所以可以在页头中存储同级指针来解决。缺点就是在页分裂、页合并时也需要更新同级指针.

### 3、最右指针

B树分隔键有严格的不变式： 用于将树拆分为子树并对这些子树进行遍历，因此指向子页的指针总是比指向键的指针多一个。在比如sqlite的实现里，往往是一个分隔键有一个子指针，而最后一个指针(即最右指针)则放在页头。如果最右指针指向的页被拆分，则新的单元格会被追加到父节点上，同时重新分配最右指针，如下图:

![Untitled](B%E6%A0%91%E5%AE%9E%E7%8E%B0%20b70b89280e1d470fa8139b3412711cdb/Untitled.png)

### 4、节点的高键

节点的高键表示当前节点下的子树中可能存在的最高的键，并且通常在单元格中将将最右指针与节点的高键存储在一起。比如PostgreSQL就使用了这种方法，成为Blink树。

Blink树向每个节点添加一个K(n+1)键，它指定了指针P(n)指向的子树中所存储的键的上限，因此也可以表示当前子树中所存储的值的一个上限

在有高键的情况下，指针可以成对存储，并且每个单元格都有对应的指针，这可以简化最右指针的处理，因为没有那么多的边界条件需要考虑。

![Untitled](B%E6%A0%91%E5%AE%9E%E7%8E%B0%20b70b89280e1d470fa8139b3412711cdb/Untitled%201.png)

### 5、溢出页

节点大小和树扇出是固定且不会动态改变的，如果我们的树中存在变长值(比如字符串)，那么页只能够放下少数几个值，如果值很小，我们最终会浪费保留的空间.

B树算法规定每个节点持有特定数量的元素，由于某些值具有不同的大小，所以根据B树算法，可能会出现这样一种情况: 节点未满，但是保存该节点固定大小的页上没有更多的可用空间了，所以需要找到一种方法来增加或扩展页大小，比如我们可以从多个链接起来的页中构建节点。

例: 默认页大小为4K，插入几个值之后，数据大小增加到4K以上，此时我们并不使用任意大小的页，而是允许节点以4K为增量进行增长，因此我们可以分配一个4K的扩展页，并从原始页链接到它。这些链接起来的页被称为溢出页(overflow page)，原始页称为主页(primary page).

大多数B树实现的方式是最多只允许在节点中直接存储某个固定字节数量的载荷数据，并将其余字节溢出到溢出页，这个数值是通过将节点大小除以扇出得到的。使用该方法，我们不会遇到页面没有可用空间的情况，因为页面总是至少有N * max_payload_size个字节，当插入的数据大于max_payload_size时，检查节点是否已经具有任何相关联的溢出页。如果溢出页已经存在并且有足够的可用空间，则要写入的数据中的额外字节将会溢出到该溢出页；否则将分配新的溢出页。

![Untitled](B%E6%A0%91%E5%AE%9E%E7%8E%B0%20b70b89280e1d470fa8139b3412711cdb/Untitled%202.png)

当分配第一个溢出页时，其页ID存储在主页的头部，如果单个溢出页不够，则通过链表的方式将多个溢出页链接在一起。

对于数据记录，我们必须定位其溢出部分，以便将其返回用户，因为这是一个不那么频繁的操作，所以问题不大；如果所有的数据记录都过大，那么值得考虑采用针对长值的blob存储。

### 6、二分搜索

B树页中的单元格按插入顺序存储，只有单元格偏移量保留了逻辑元素的顺序。为了对单元格进行二分搜索，我们选取中间的单元格偏移量，跟随它的指针来定位单元格，然后将这个单元格的键与搜索键进行比较，以此决定搜索应该向左还是向右继续，此后分区递归这个过程，直到找到要搜索的元素或插入点，如下图:

![Untitled](B%E6%A0%91%E5%AE%9E%E7%8E%B0%20b70b89280e1d470fa8139b3412711cdb/Untitled%203.png)

### 7、传播分裂与合并

B树的分裂与合并可以传播到更高的层，为此我们需要一条从将要分裂或合并的叶节点遍历回根节点的路径。

所以B树节点往往可以包含父指针，就像同级指针一样，每当父节点发生变化，父节点指针就必须更新，当带有页标识符的分隔符键从一个节点转移到另一个节点时(比如父节点分裂、合并或再平衡时)，都需要更新。

一些实现将父指针用于叶节点的遍历来避免死锁(死锁可能是在使用同级指针时发生)， 要寻址和定位同级节点，我们可以递归跟随父节点的指针，此时搜索就会递归地向上继续，最终到达根节点，并继续向下返回到叶子层。

**导航信息**

如果不存储和维护父节点指针，则我们还可以跟踪在遍历目标叶节点路径上的节点，并在发生级联分裂或合并的情况下，以相反的顺序跟踪父节点链路。

在进行B树的插入或删除操作时，我们首先从根节点到叶节点遍历树来找到目标节点或插入点，由于我们不能预先知道操作是否会导致分裂或合并，所以必须收集导航信息(即一路下来的引用)，用于在传播分裂或合并时进行反向回溯。对此最自然的数据结构就是栈，过程如下图:

![Untitled](B%E6%A0%91%E5%AE%9E%E7%8E%B0%20b70b89280e1d470fa8139b3412711cdb/Untitled%204.png)

### 8、再平衡

一些B树的实现方案试图推迟分裂和合并操作，以便通过在层内再平衡各元素来平摊代价，比如元素从占用较多的节点转移到占用较少的节点中，通过这一方式尽可能推迟分裂或合并，虽然维护代价可能更高一些，但是有助于提高节点利用率来减少树的层数。

B*树持续在相邻节点之间分发数据，直到两个同级节点都满。另外，该算法不是将单个节点拆分为两个半空节点，而是将两个节点拆分为三个节点，每个节点时三分之二满的。Sqlite在实现中使用该变体，这种方法通过推迟分裂来提高平均占用率，但需要额外的跟踪和平衡逻辑；而更高的利用率也意味着更高效的搜索，因为树的高度更低，通往被搜索叶节点的路径上的页也更少。

再平衡过程参考下图:

![Untitled](B%E6%A0%91%E5%AE%9E%E7%8E%B0%20b70b89280e1d470fa8139b3412711cdb/Untitled%205.png)

### 9、仅在右侧追加

许多数据库系统使用单调自增的数值作为主索引的键。这为优化创造了机会，因为所有的插入都发生在索引的末尾，所以大多数分裂发生在每层的最右节点上。此外，由于键是单调递增的，所以考虑到追加相对更新和删除的比例很低，相对于键随机排列的情况下，非叶页上的碎片化程度更低。

PostgreSQL称这种情况为快速路径。当插入键严格按大于最右页中的第一个键，并且最右有足够的空间来容纳新插入的条目时，新条目被插入缓存的最右叶中的适当位置，并且可以跳过整个读取路径。

**批量加载**

如果我们已经预先对数据进行了排序，并且想要批量加载它们，或者不得不进行树的重建，那么可以进一步拓展仅在右侧追加的技术。由于树所需的数据已经被排序，所以在批量加载中，我们只需要将数据项追加到最右边位置。

这种情况下，我们可以完全避免分裂和合并，并自下而上地构建树，逐层写出，或者在右足够的指针指向已经写出的低层节点时立即写出高层节点。

### 10、压缩

存储原始的、未压缩的数据会导致显著的开销，因此许多数据库提供了压缩数据的方法以节省存储空间。这里显然是要在访问速度和压缩率之间进行权衡： 较大的压缩率可以提升数据存储空间利用率，允许你在一次访问中获取更多的数据，但可能需要更多的内存和CPU周期来进行压缩和解压缩。

我们可以在不同的粒度级别上进行压缩.

- 整个文件： 最好的压缩率，但是为了寻址一个特定页，必须访问整个文件或其包含压缩元数据的段，然后将其解压缩并使其可用，应用范围有限。
- 按页压缩数据: 页可以独立进行压缩和解压缩，从而允许你将压缩与页的加载和刷盘耦合起来。但是被压缩的页可能只占用磁盘快的一部分，并且由于传输通常是以磁盘快进行，所以可能需要换入额外的字节。如下图

![Untitled](B%E6%A0%91%E5%AE%9E%E7%8E%B0%20b70b89280e1d470fa8139b3412711cdb/Untitled%206.png)

- 仅压缩数据，要么按行，要么按列。这种情况下，页的管理和压缩都是解耦的。

针对不同块大小评估不同的压缩算法综述有很多，通常集中在四个衡量指标上: 内存开销、压缩性能、解压缩性能和压缩比。

### 11、清扫与维护

在B树查询的同时还会发生一些其他的过程，包括维护存储完整性、回收空间减少开销以及维持页有序。在后台执行这些操作可以使我们节省一些时间，避免在插入、更新和删除期间为清理付出代价。

例： 发生更新、删除之后分槽页的碎片化

![Untitled](B%E6%A0%91%E5%AE%9E%E7%8E%B0%20b70b89280e1d470fa8139b3412711cdb/Untitled%207.png)

**更新和删除导致的碎片化**

让我们考虑一下在什么情况下页会进入这样一种状态: 页包含无法寻址的数据，并且不得不进行压实(compact)。在叶子层，删除操作仅从头部移除单元格偏移量，而单元格本身保持不变，这样做之后，对应的单元格就不再是可寻址的了。

由于删除操作仅丢弃单元格偏移量，而非搬运剩余单元格或物理地移除目标单元格以释放占用的空间，所以释放的字节可能最终分散在整个页上。这种情况下，页就是碎片化的(fragmented)，需要进行碎片整理

**页的碎片整理**

负责空间回收和页重写的过程称为压实、清扫或直接称为维护。如果页中没有足够的物理空间，则可以在写入时同步进行页重写(以避免创建不必要的溢出页)，但压实通常是指一个单独的异步过程，负责遍历页、进行垃圾回收并重写其内容。

这个过程会回收死亡的单元格所占用的空间，并按逻辑顺序重写单元格。当页被重写时，它可能被移动到文件中的新位置，未使用的内存页变为可用状态并归还至缓冲区，新的可用磁盘页ID被添加到空闲页列表，这些信息必须被持久化，才能在节点崩溃和重启时幸存下来，并确保可用空间不会丢失或泄漏。