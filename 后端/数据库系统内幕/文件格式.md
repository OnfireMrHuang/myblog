# 文件格式

在介绍了B树的基本语义之后，接下来就要探索B树以及其他数据结构是如何在磁盘上实现的。这就需要一种易于构造、修改和解析的文件格式，通过了解其通用原理和实践，来帮助我们去如何设计各种磁盘结构，比如B树。

## 一、动机

构建一种文件格式十分类似于我们在内存模型中去构建一种数据结构，不同点是在内存中我们不必考虑诸如是否有连续的内存段、内存释放之后会怎么等问题，而在磁盘上，我们必须自己处理垃圾收集和碎片问题。因此，对于在磁盘上进行数据布局的重要性也远大于内存。

要想设计一个高效的磁盘数据结构，我们需要仔细设计布局来确保可以高速访问，还需要考虑持久性存储介质的特性、设计二进制数据格式，并找出一种高效的序列化和反序列化方法。

## 二、二进制编码

如何以二进制形式表示键和数据记录，如何将多个值组合成更复杂的结构，以及如何实现可变长度的数据类型和数组。

**2-1 原始类型**

数据记录由数值、字符串、布尔值之类的原始类型以及它们的组合构成。但是当通过网络传输数据或是将其存储在磁盘上时，我们只能使用字节序列。这意味着，当我们发送或写入一条记录时必须先序列化，我们接受或读取一条记录时必须先将其反序列化。

**2-2 字符串和变长数据**

字符串和其他变长数据类型可以序列化为一个表示长度的数值字段size再加上size个字节，后面这些字节是实际的数据。这种表示形式常称为Pascal字符串，Pascal字符串的一种替代是以空结尾的字符串，相比之下，Pascal字符串有如下优点:

- 常数时间内获取字符串的长度而无须遍历整个字符串
- 在如Go及Rust等语言中，可以通过直接使用内存中size个字节的切片将字节数组传入字符串构建函数的方式来构造字符串。

**2-3 按位打包的数据: 布尔值、枚举值和标志**

布尔值可以用单个字节表示，分别将true和false编码为1和0，由于布尔值只有两个取值，一个完整字节太浪费，所以开发者常常将每8个布尔值合成一批。

枚举值可以表示为整数，常用于二进制格式和通信协议。枚举值主要用于表示重复多、基数少的值。

标志是打包的布尔值和枚举值的组合。标志可以表示多个非互斥的布尔值参数，一个字节可以表示8个布尔值。例如，可以用来表示是否包含值单元、值是定长还是变长、是否存在与当前节点关联的溢出页。每个比特位都代表一个标志值，所以可以用2的幂用作掩码，然后利用位掩码和位运算符从打包的值中读取各个标志位。

## 三、**通用原理**

在设计一种文件格式时，首先要确定寻址方式： 比如是否要将文件拆分为相同大小的页、哪些页由单个块或多个连续块组成。文件通常以定长的header开始，可能以一个定长的trailer结束，尾部包含需要被快速访问的辅助信息或解析文件其余部分所必要的信息。

![Untitled](%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%20bdd0a3b0b4d346ca8124161b2461950f/Untitled.png)

## 四、**页的结构**

数据库将数据记录存储在数据文件和索引文件中。这些文件被划分为固定大小的单元，称为页。页大小通常是文件系统块的整数倍，一般是4~16KB。

![Untitled](%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%20bdd0a3b0b4d346ca8124161b2461950f/Untitled%201.png)

缺点：

- 除非是在最右处，否则向其他位置插入一个键需要移动已有的元素
- 无法有效地管理或访问变长记录，只适用于定长的数据.

## 五、 **分槽页**

针对页格式，我们通常有如下的需求:

- 能够以最小的开销存储变长记录
- 回收已删除记录所占用的空间
- 引用页中的记录，无论这些记录具体在什么位置

而为了解决上面这些问题，就引出了分槽页(slotted page)技术，即将页分成很多槽。

我们将页组织成一个槽或单元格的集合，并将指针和单元格分别存放在页两侧的独立内存区域中，若想改变记录原来的顺序，我们只需要重新组织单元格的指针；若要删除一条记录，我们只需要将记录的指针置为空或删除指针即可。

![Untitled](%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%20bdd0a3b0b4d346ca8124161b2461950f/Untitled%202.png)

让我们来看看上述方法是如何解决本节开头提到的问题的

- 最小开销: 分槽页唯一的额外开销是一个指针数组，用于保存记录实际所在位置的偏移量。
- 空间回收: 通过对页进行碎片整理和重写，就可以回收空间。
- 动态布局: 从页外部，只能通过槽ID来引用槽，而确切的位置是由页内部决定的.

## 六、 **单元格布局**

有了标志性、枚举值和原始类型，我们就可以开始设计单元格布局了。设计完单元格之后再合成页，再将页组合成树。单元格分为键单元格和键值单元格，键单元格包含一个分割键和一个指针，该指针指向两个相邻键之间的页。键值单元格包含键和相关联的数据记录。

构成一个键单元格需要以下信息:

- 单元格类型(可以从页的元数据推断出来)
- 键的长度
- 该单元格指向的子页的ID
- 键的数据(以字节表示)

![Untitled](%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%20bdd0a3b0b4d346ca8124161b2461950f/Untitled%203.png)

键值单元格存放数据记录而非子页ID。除此之外，基本和键单元格类似:

- 单元格类型(从页的元数据推断出来)
- 键的长度
- 值的长度
- 键的数据(以字节表示)

![Untitled](%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%20bdd0a3b0b4d346ca8124161b2461950f/Untitled%204.png)

## 七、**将单元格放进分槽页**

要将单元格组织成页，我们可以使用分槽页技术。单元格追加到页的右侧(从尾到头)，单元格偏移量/指针放在页的左侧，如下图所示:

![Untitled](%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%20bdd0a3b0b4d346ca8124161b2461950f/Untitled%205.png)

键可以不按顺序插入，其逻辑上的顺序是通过维护偏移量指针的顺序来实现的。这种设计使得向页中追加单元格只需要最低限度的工作量，因为无论是在插入、更新还是删除操作中，始终都不需要移动单元格的位置。比如对单元格数据进行字典排序，只需要排序偏移量就好了:

![Untitled](%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%20bdd0a3b0b4d346ca8124161b2461950f/Untitled%206.png)

## 八、管理变长数据

从页删除一条记录不用删除实际的单元格，也不用移动其他单元格以重用这些释放的空间。相反，可以将这个单元格标记为删除，并根据被释放内存的大小以及指针更新内存中的可用列表。可用列表保存了可用段的偏移量及其大小，每当插入新单元格时，我们首先检查可用性列表，看看是否有能放得下的段。

![Untitled](%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%20bdd0a3b0b4d346ca8124161b2461950f/Untitled%207.png)

当要使用哪一个空闲块时，是通过以下策略计算的:

- 首次适配优先
    - 该方法可能会造成较大的额外开销，因为当我们把数据填进第一个合适的段之后，剩余的空间可能不够放下其他的单元格，因而被浪费掉了。
- 最佳适配优先
    - 在该方法中，我们尝试寻找一个段，使得插入之后段内剩余的空间最小。

如果执行后还是找不到足够长的连续字节来存放新的单元格，但是有足够多的碎片字节可用，我们会读出所有存活的单元格再重新写入，即对页进行碎片整理，以回收空间来留给新的写入。如果在碎片整理之后依然没有足够的空间，就需要创建一个溢出页.

## 九、版本

随着数据库系统的不断演进，开发人员不断加入新功能并修复bug和性能问题。其后果是，二进制文件的格式也会发生变化，大多数时候，任一版本的存储引擎都要支持不止一种序列化格式。为此，我们必须能够确定当前文件是什么版本.

去确定版本的几种方式

- 文件名中带版本前缀，这样不用打开文件就可以知道文件版本。
- 将版本存储在单独的文件中。比如postgreSQL
- 直接存储在文件的头部，该情况下，头部的一部分必须用一种不随版本变化的格式进行编码，在找出版本之后，再创建特定的读取器来解析文件内容。

## 十、校验和

磁盘上的文件可能会由于软件错误或硬件故障而损坏。为了尽早识别这些问题，避免将

损坏的数据传播到其他子系统甚至节点，我们可以使用校验和(checksum)以及循环冗余校验(CRC)。

校验和是最弱的保证形式，它不能检测多个比特位的损坏，通常校验和是用XOR结合奇偶校验或求和来计算的

CRC可以帮助检测突发错误(比如多个连续比特位的损坏)，其通常使用查找表和多项式除法来实现。多位错误的检测至关重要，因为大部分在通信网络和存储设备中发生的故障都是以这种方式呈现的。

非加密哈希和CRC不应当用于验证数据是否已被篡改，对于这类场景，需要使用专为安全性设计的强加密哈希，CRC的主要目标是确保数据没有非人为的、意外的变化，而非用于抵御攻击或人为修改。

在将数据写人磁盘之前，我们计算其校验和井将它与数据一同写入。当读取数据时，我们重新计算校验和并把它与之前写入的校验和进行比较。如果校验和不匹配，我们就知道发生了损坏，因而不应当再使用这些数据.

由于计算整个文件的校验和通常是不切实际的，而且不太可能每次访问文件都读取全部内容，所以校验和通常是针对每个页计算的，并保存在页头部。这样一来，校验和可以更健壮（因为仅针对小部分数据），而且就算单个页发生损坏，我们也不用丢弃整个文件.