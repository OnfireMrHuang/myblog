# B树变体

B树的变体有几个共同点： 树结构、通过分裂合并实现平衡，以及查找和删除算法。而并发性、磁盘页、同级节点之间的链接和维护进程等细节则可能有所不同。如下是该章要介绍的B树变体:

- 写时复制B树
- 惰性B树
- FD树
- Bw树
- 缓存无关树

### 写时复制

有些数据库并不构建复杂的锁机制，而是使用写时复制技术来保证并发操作时的数据完整性。最大的优点是读取者不需要同步。因为已写入的页是不可变的，可以在不需要额外加锁的情况下被访问；因为写操作是针对复制页进行的，所以读取者不会阻塞写入者。任务操作都不会得到一个处于不完整状态的页，即使是系统崩溃也不会使页处于损坏状态，因为只有当所有页的修改都完成时，最顶端的指针才会切换。

**实现写时复制: LMDB**

LMDB全称Lightning Memory-Mapped Database，是OpenLDAP项目使用的键值存储，因为其设计架构，LMDB不需要页缓存(直接通过内存映射)、预写日志、生成检查点或压实等操作。

## 抽象节点更新

- B树节点中的原始二进制数据是可以被重新解释的，且可以被原生指针所操作。在这种情况下，节点是按照结构体定义的，这些结构体使用指针和运行时类型转换来操作背后原始的二进制数据，更常见的情况是它们指向页缓存管理的内存区域，或者使用内存映射。（读时使用）
- B树节点物化为语言原生的对象或结构体。(写时使用)
- 通过包装器对象提供对节点背后缓冲区的访问，在B树中的更改被执行后该包装器对象会立即物化这些更改。

## 惰性B树

惰性B树降低了更新B树的成本，并使用更轻量级的、并发友好且更新友好的内存结构来缓冲并延迟传播更新。

![Untitled](B%E6%A0%91%E5%8F%98%E4%BD%93%20b41bcbf40e1045c7b993cbc83b453de7/Untitled.png)

在读取过程中会访问更新缓冲区： 其内容将原与原始磁盘页中的内容进行合并，以返回最新的数据。当刷写页时，更新缓冲区内容将与页内容协调然后保存在磁盘上，以覆盖原始页。如果协调后页的大小大于最大值，则将其拆分为多个页。更新缓冲区使用跳表 (skiplist) 来实现，跳表具有类似于搜索树的复杂度 [PAPADAKIS93] ，但具有更好的并发性 [PUGH90a]。

如下图所示，wiredTiger中干净页和脏页都有内存中的版本，并且都引用磁盘上的基础镜像。脏页还有一个更新缓冲区，其主要优点是页更新和结构修改(分裂和合并)由后台线程执行，而读写进程不必等待它们完成。

![Untitled](B%E6%A0%91%E5%8F%98%E4%BD%93%20b41bcbf40e1045c7b993cbc83b453de7/Untitled%201.png)

## FD树

缓冲是一种在数据库存储中被广泛使用的思想: 有助于避免许多小的随机写操作，而作为替代，它会执行单个较大的写操作。在机械硬盘上，由于磁头的寻道，随机写会比较慢；在固态硬盘上，虽然没有要移动的部件，但是额外的写IO会增加垃圾收集的代价。

FD 树由一个小的、可变的头部树 (head tree)和多个不可变的有序段构成。当随机IO产生的时候，这种方法将暴露的区域限制在头部树上：一个对更新进行缓冲的小型B树。一旦头部树被填满，它的内容就被转移到不可变的有序段中。如果新写入的有序段的大小超过阈值，则其内容将与下一层合并，从上到下逐层传播数据记录。

如果发生删除，则通过插入墓碑(tombstone)来进行删除，该墓碑指示与相应键相关联的数据记录已经被删除，必须丢弃较低层中该键的所有数据记录，当墓碑一直传播到最低层时，它们便可以被丢弃了，因为此时可以保证已经没有需要它们遮蔽的数据项了。

![Untitled](B%E6%A0%91%E5%8F%98%E4%BD%93%20b41bcbf40e1045c7b993cbc83b453de7/Untitled%202.png)

## BW树

在原地更新的B树实现中，写放大是最显著的问题之一： 对一个B树页后续的更新可能需要在每次更新时更新其磁盘驻留页副本；第二个问题是空间放大： 即保留了额外的空间以实现更新，意味着为了传输请求数据每个有用字节，我们不得不额外传输一些空字节以及页的其余部分；第三个问题是解决并发问题和处理闩锁的复杂性。

通过使用仅追加存储来对不同节点进行批量更新，将节点链接成链，并使用内存数据结构(允许单个CAS操作)在节点之间建立指针，从而使树无锁，这中方法就是Buzzword树。

**更新链**

BW树区分基节点的写入和修改。修改(增量节点)形成一个链： 一个从最新修改到旧修改的链表，该链表末尾是基节点(base node)。每个更新都可以单独存储，而不需要重写磁盘上的现有节点。增量节点 (delta node) 可以表示插人、（与插入无法区分的）更新或删除。

缺点： 在读取过程中，必须遍历所有增量并将其应用到基节点 ，以重建实际的节点状态。

**用CAS控制并发**

维护一个允许将数据项插到子节点之前的磁盘树状结构的成本相当高：它要求我们不断地更新父节点指向最新增量的指针。这就是为什么由增量节点和基节点链接在一起而组成的 Bw 树节点具有逻辑标识符，并使用一个从标识符到其在磁盘上位置的内存映射表。使用这种映射还帮助我们摆脱闩锁： Bw 树不是在写入时获取独占所有权，而是对映射表中的物理偏移量使用 CAS 操作。

![Untitled](B%E6%A0%91%E5%8F%98%E4%BD%93%20b41bcbf40e1045c7b993cbc83b453de7/Untitled%203.png)

要更新一个BW树节点，算法需要执行以下步骤:

- 通过从根到叶遍历树来定位目标逻辑叶节点。映射表包含了到更新链中的目标基节点或最新增量节点的虚拟链接。
- 使用指向在步骤1中定位的基节点（或指向最新的增量节点）的指针来创建一个新的增点节点
- 用指向步骤2期间创建的新增量节点的指针来更新映射表。

步骤3中的更新操作可以使用 CAS 这个原子操作来完成，因此与指针更新并发的所有读取都被安排在写入之前或之后，读取者或写入者都不会被阻塞。 在此之前的读取是沿着旧指针进行的，看不到新的增量节点，因为它尚未被放置。而在此之后的读取则是沿着新指针进行的，可以观察到更新。如果两个线程试图将一个新的增量节点放置到同一个逻辑节点，那么只有其中一个线程可以成功，而另一个线程必须重试该橾作。

**结构修改操作**

Bw 树的逻辑结构类似于B树，这意味着节点仍然可能增长得太大(溢出）或缩小到几乎为空（下溢），井且需要结构修改操作 (Structure Mod cation Operation, SMO) ，例如分裂和合井。但它们的实现方式不同:

分裂SMO是从合并被分裂节点的逻辑内容开始的，也就是将其增量应用于其基节点，并创建一个包含分裂点右侧元素的新页。在此之后，该过程分两步进行 (WANG18):
1. 分裂：一个特殊的分裂增量节点被附加到要分裂的节点，以通知读取者正在进行分裂。这个分裂增量节点持有一个中点分隔符键以使分裂节点中的记录变得无效，并且其还持有一个到新的逻辑同级节点的链接
2. 父节点更新：在这一点上，情况类似于 Blink 树的半分裂，因为该节点通过分裂增量节点的指针而变为可用，但其尚未被父节点引用，并且读取者必须通过旧节点遍历同级指针以到达新创建的同级节点。一个新节点作为子节点被添加到父节点，这样读取者就可以直接到达它，而不是通过分裂节点被重定向，此时分裂就完成了。

合井 SMO 工作方式也是类似的：
I. 删除同级节点： 创建一个特殊的删除增量节点井将其追加到右同级节点，它代表SMO 的开始，并标记右同级节点以便删除。
2. 合并节点：在左同级节点上创建一个合并增加节点，指向右同级节点的内容，并使其成为左同级节点的逻辑组成部分。
3. 父节点更新: 此时，可以从左边的同级节点访问右边同级节点的内容。要完成合并过程，必须从父节点中删除到右同级节点的链接

并发SMO需要在父节点上放置一个附加的中止增量节点，以防止并发分裂和合并。 [WANG18]中止增量节点与写入锁的工作方式类似：一次只能有一个线程具有写访问权限，任何试图向该增量节点追加新记录的线程都将被中止。在 SMO 完成时，可以从父节点删除该中止增量节点

**合并和垃圾收集**

增量链可以变得任意长而不需要任何附加动作。增量链越长，读取的开销就越大，因此我们需要尝试将增量链的长度保持在合理的范围内。当它达到一个可配阈值时，我们通过将基节点的内容与所有增量合并 (cons olidate) 来重建节点，从而生成一个新的基节点。随后将新节点写人磁盘上的新位置，井更新映射表中的节点指针以指向该节点。

Bw 树是一个有趣的B树变体， 其在如下几个重要方面进行了改进：写放大、非阻塞访问和缓存友好性。实验性的存储引擎 Sled 实现了它的一个修改版本。而 CMU 数据库组开发了Bw 树的一个内存版本，称为 OpenBw 树，并发布了一个实用的实现指南 [WANG18]

## 缓存无关B树

块大小、节点大小、高速缓存行对齐和其他可配参数会影响B树的性能。一种称为缓存无关结构的新数据结构类型 [DEMAINE02] 给出了渐近最优的性能、而无须考虑底层的内存层次结构和对上述参数的调整。这意味着该算法不需要知道缓存行、 文件系统块和磁盘页的大小。

关于缓存无关B树的实现在业内几乎没有，这里不再展开。

## 小结

B树的原始设计有几个缺点，这些缺点在机械磁盘上没有太大影响，但在固态硬盘上使用时会使其效率降低。 树有很高的写放大（由页重写引起）和很高的空间开销．因为B树必须在节点中为将来的写入保留空间。

可以使用缓冲来减少写放大。惰性B树（如 WiredTiger 树）将内存缓冲区附加到单个节点或节点组，通过缓冲页中的后续更新来减少所需IO操作的数量。

为了减少空间放大， FD 树使用了不可变性：数据记录存储在不可变的有序段中，而可变B树的大小是有限的。

Bw 树也利用不可变性来解决空间放大问题。 B树节点和对它们的更新被存储在分离的磁盘位置上，并持久保存在日志结构存储中。与原始B树设计相比，其写入放大被减少，因为对属于单个逻辑节点内容的协调相对不频繁。 Bw 树不需要闩锁来保护页以免受并发访问的影响，因为内存中存储的是逻辑节点之间的虚拟指针。